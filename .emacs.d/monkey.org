#+TITLE: Mike Aldred's Emacs configuration.

* Configuration
** About this file
<<babel-init>>

I was searching around the Internet one day, and I came across Sacha
Chua's blog, [[http://sachachua.com/blog/][Living an awesome life]]. Boy did that open my eyes, so,
I've been inspired to work on my general productivity, and I think
that org-mode and Emacs is probably a way to do that. So, I'm now
going to try and throw myself deep into Emacs, and this new config is
my attempt at that. Following Sacha's example, I'm going to try using
the literate programming style.

** Personal information

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Mike Aldred"
        user-mail-address "mike.aldred@luminousmonkey.org")
#+END_SRC

** General configuration
*** Track frequency of keys
I need improve the ergonomics of my Emacs usage and keyboard. So, measure how I use Emacs and look for improvements.

#+begin_src emacs-lisp
  (use-package keyfreq
    :config
    (keyfreq-mode 1)
    (keyfreq-autosave-mode 1))
#+end_src

*** Normal bindings

These are "normal" bindings, they don't rely on anything strange to be
loaded beforehand. As recommended by Steve Yegge in [[https://sites.google.com/site/steveyegge2/effective-emacs][Effective Emacs]].

#+BEGIN_SRC emacs-lisp
  ;; This gets replaced later by Helm, but have it here if the config
  ;; runs into problems.
  (define-key global-map (kbd "C-x C-m") 'execute-extended-command)
  (define-key global-map (kbd "C-w ") 'backward-kill-word)
  (define-key global-map (kbd "C-x C-k") 'kill-region)
  (define-key global-map (kbd "C-c C-k") 'kill-region)
#+END_SRC

*** Visual bell

I have delicate ears.

#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
  (setq visible-bell t)
#+END_SRC

*** Theme
Get fonts and colours up as soon as possible.

Font depends on the system we're using.
#+BEGIN_SRC emacs-lisp
  ;; Be sure we have a fallback font for symbols. Also, could be running
  ;; emacs client, which doesn't appear to set the 'window-system. So,
  ;; attach to the hooks.

  ;; https://www.emacswiki.org/emacs/SettingFrameColorsForEmacsClient
  (defun setup-window-system (&rest frame)
    (if (window-system)
        (progn
          (set-default-font "Inconsolata 18")
          ;; Fix Unicode
          (use-package unicode-fonts
            :config (unicode-fonts-setup))
          ;; Also fix powerline
          (powerline-reset))))

  (require 'server)

  (defadvice server-create-window-system-frame
      (after set-window-system-frame-colours ())
    "set custom frame colours when create the first frame on a display"
    (message "Running after frame-initialize")
    (setup-window-system))

  (ad-activate 'server-create-window-system-frame)
  (add-hook 'after-make-frame-functions 'setup-window-system)
#+END_SRC

Custom theme path, and load the theme.
#+BEGIN_SRC emacs-lisp
  (use-package color-theme)

  (add-to-list 'custom-theme-load-path
               (expand-file-name "themes" user-emacs-directory))

  (load-theme 'jellybeans t)
#+END_SRC

Spaceline, because try to make it look good so people ask what editor you use.

#+begin_src emacs-lisp
  (use-package spaceline-config
    :ensure f
    :load-path ("site-lisp/spaceline" "site-lisp/powerline")
    :config
    (progn
      (spaceline-emacs-theme)
      (spaceline-helm-mode)
      (setq powerline-default-separator 'wave)
      (setq powerline-height 32)))
#+end_src

*** Backups

Stop Emacs from saving backups in the current directory.

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist
        `(("." . ,(expand-file-name "backups" user-emacs-directory))))

  (setq auto-save-file-name-transforms
        `((".*" ,(expand-file-name "auto-saves" user-emacs-directory) t)))
#+END_SRC

Disk space is cheap. Save lots.

#+BEGIN_SRC emacs-lisp
(setq delete-old-versions -1)
(setq version-control t)
(setq vc-make-backup-files t)
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
#+END_SRC

Turn off lockfiles.

#+begin_src emacs-lisp
  (setq create-lockfiles nil)
#+end_src

*** History

From http://www.wisdomandwonder.com/wordpress/wp-content/uploads/2014/03/C3F.html
#+BEGIN_SRC emacs-lisp
(setq savehist-file "~/.emacs.d/savehist")
(savehist-mode 1)
(setq history-length t)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring))
#+END_SRC

*** Sentences end with a single space

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

*** Helm - interactive completion
I've been using ido, however, I need to try Helm as well, to see if I
like it better.

#+BEGIN_SRC emacs-lisp
  (use-package helm
    :demand t
    :diminish helm-mode
    :bind (("C-c h" . helm-mini)
           ("C-h a" . helm-apropos)
           ("C-x C-b" . helm-buffers-list)
           ("C-x b" . helm-buffers-list)
           ("M-y" . helm-show-kill-ring)
           ("M-x" . helm-M-x)
           ("C-x C-m" . helm-M-x)
           ("C-x c o" . helm-occur)
           ("C-x c s" . helm-swoop)
           ("C-x c SPC" . helm-all-mark-rings)
           ("C-x C-f" . helm-find-files))
    :init
    (require 'helm-config)
    (helm-mode 1)
    (ido-mode -1))
#+END_SRC

*** Helm Swoop - quickly finding lines

#+begin_src emacs-lisp
  (use-package helm-swoop
    :demand t
    :bind (("C-x c s" . helm-swoop)))
#+end_src

Great for describing bindings. I'll replace the binding for =where-is= too.

#+BEGIN_SRC emacs-lisp
  (use-package helm-descbinds
    :bind (("C-h b" . helm-descbinds)
           ("C-h w" . helm-descbinds))
    :config
    (require 'helm-config))
#+END_SRC

#+begin_src emacs-lisp
  (use-package helm-ag)
#+end_src

*** Mode line format

Display a more compact mode line.

#+BEGIN_SRC emacs-lisp
  ;; (use-package smart-mode-line
  ;;   :defer t
  ;;   :init
  ;;   (progn
  ;;   (setq-default
  ;;    mode-line-format
  ;;    '("%e"
  ;;      mode-line-front-space
  ;;      mode-line-mule-info
  ;;      mode-line-client
  ;;      mode-line-modified
  ;;      mode-line-remote
  ;;      mode-line-frame-identification
  ;;      mode-line-buffer-identification
  ;;      "   "
  ;;      mode-line-position
  ;;      (vc-mode vc-mode)
  ;;      "  "
  ;;      mode-line-modes
  ;;      mode-line-misc-info
  ;;      mode-line-end-spaces))))
#+END_SRC

*** Show column number

I sometimes need to know where I am in a line.
#+begin_src emacs-lisp
  (column-number-mode 1)
#+end_src

*** Change "yes or no" to "y or n"

Lazy people like me never want to type "yes" when "y" will suffice.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Minibuffer editing - more space!

    Sometimes you want to be able to do fancy things with the text
    that you're entering into the minibuffer. Sometimes you just want
    to be able to read it, especially when it comes to lots of text.
    This binds =C-M-e= in a minibuffer) so that you can edit the
    contents of the minibuffer before submitting it.

#+BEGIN_SRC emacs-lisp
  ;; (use-package miniedit
  ;;   :defer t
  ;;   :commands minibuffer-edit
  ;;   :init (miniedit-install))
#+END_SRC

*** Undo tree mode - visualize your undos and branches

People often struggle with the Emacs undo model, where there's really
no concept of "redo" - you simply undo the undo.
#
This lets you use =C-x u= (=undo-tree-visualize=) to visually walk
through the changes you've made, undo back to a certain point (or
redo), and go down different branches.

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :diminish undo-tree-mode
    :config
    (progn
      (global-undo-tree-mode)
      (setq undo-tree-visualizer-timestamps t)
      (setq undo-tree-visualizer-diff t)))
#+END_SRC

*** Help - guide-key

It's hard to remember keyboard shortcuts. The =guide-key= package pops
up help after a short delay.

#+BEGIN_SRC emacs-lisp
  (use-package guide-key
    :diminish guide-key-mode
    :config
    (progn
      (setq guide-key/guide-key-sequence '("C-x r" "C-x 4" "C-c" "C-c C-m"))
      (guide-key-mode 1)))  ; Enable guide-key-mode
#+END_SRC

*** UTF-8

From http://www.wisdomandwonder.com/wordpress/wp-content/uploads/2014/03/C3F.html
#+BEGIN_SRC emacs-lisp
(prefer-coding-system 'utf-8)
(when (display-graphic-p)
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+END_SRC

*** Browser
Use Google Chrome for browsing.

#+begin_src emacs-lisp
  (setq browse-url-browser-function 'browse-url-generic
        browse-url-generic-program "google-chrome-stable")
#+end_src

*** Exec Path
I need to make sure my own local programs get in the path. Under OSX it seems
the path isn't read correctly.

#+begin_src emacs-lisp
  (let ((path-from-shell (replace-regexp-in-string "[ \t\n]*$" "" (shell-command-to-string "$SHELL --login -i -c 'echo $PATH'"))))
      (setenv "PATH" path-from-shell)
      (setq exec-path (split-string path-from-shell path-separator)))

#+end_src

** Navigation
*** Projectile
For navigating files in a project easily.

#+begin_src emacs-lisp
  (use-package projectile
    :diminish projectile-mode
    :config
    (use-package helm-projectile)
    (helm-projectile-on)
    (projectile-global-mode t))
#+end_src

*** Helm-swoop - quickly finding lines

This promises to be a fast way to find things. Let's bind it to
=Ctrl-Shift-S= to see if I can get used to that...

#+BEGIN_SRC emacs-lisp
  (use-package helm-swoop
    :bind
    (("C-S-s" . helm-swoop)
     ("M-i" . helm-swoop)
     ("M-s s" . helm-swoop)
     ("M-s M-s" . helm-swoop)
     ("M-I" . helm-swoop-back-to-last-point)
     ("C-c M-i" . helm-multi-swoop)
     ("C-x M-i" . helm-multi-swoop-all))
    :config
    (progn
      (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
      (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)))
#+END_SRC

*** Regex search forward and backward

#+begin_src emacs-lisp
  (bind-key "M-s" 'isearch-forward-regexp)
  (bind-key "M-r" 'isearch-backward-regexp)
#+end_src

*** Ace jump mode

For quickly navigating in the current buffers.

#+BEGIN_SRC emacs-lisp
  (use-package ace-jump-mode
    :config
    (setq ace-jump-mode-submode-list
          '(ace-jump-char-mode
            ace-jump-word-mode
            ace-jump-line-mode)))
#+END_SRC

*** Ace window

For quickly jumping, moving and deleting windows.

#+begin_src emacs-lisp
  (use-package ace-window
    :config (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    :bind ("C-x o" . ace-window))
#+end_src

*** Key chords

Key chords allows you to press two keys in quick succession to run a
command. You can find details on uncommon letter combinations for the
English language at [[http://www.johndcook.com/blog/2015/02/01/rare-bigrams/][Rare letter combinations and key chords]].

Some code from http://emacsredux.com/blog/2013/04/28/switch-to-previous-buffer/

#+BEGIN_SRC emacs-lisp
(defun my/key-chord-define (keymap keys command)
  "Define in KEYMAP, a key-chord of two keys in KEYS starting a COMMAND.
\nKEYS can be a string or a vector of two elements. Currently only elements
that corresponds to ascii codes in the range 32 to 126 can be used.
\nCOMMAND can be an interactive function, a string, or nil.
If COMMAND is nil, the key-chord is removed.

MODIFICATION: Do not define the transposed key chord.
"
  (if (/= 2 (length keys))
      (error "Key-chord keys must have two elements"))
  ;; Exotic chars in a string are >255 but define-key wants 128..255 for those
  (let ((key1 (logand 255 (aref keys 0)))
        (key2 (logand 255 (aref keys 1))))
    (define-key keymap (vector 'key-chord key1 key2) command)))
(fset 'key-chord-define 'my/key-chord-define)

(defvar my/key-chord-command-map (make-sparse-keymap))
(define-key my/key-chord-command-map "k" 'kill-sexp)
(define-key my/key-chord-command-map "." 'repeat)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package key-chord
    :config
    (progn
      (fset 'key-chord-define 'my/key-chord-define)
      (setq key-chord-one-key-delay 0.16)
      (key-chord-mode 1)
      ;; k can be bound too
      (key-chord-define-global "uu" 'undo)
      (key-chord-define-global "jj" 'ace-jump-word-mode)
      (key-chord-define-global "jw" 'ace-window)
      (key-chord-define-global "jl" 'ace-jump-line-mode)

      ;; not an ace-jump, but still useful
      (key-chord-define-global "jZ" 'ace-jump-zap-to-char)
      (key-chord-define-global "FF" 'helm-find-files)))
#+END_SRC

*** Move to beginning of line
Copied from http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/

#+BEGIN_SRC emacs-lisp
(defun my/smarter-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.

If ARG is not nil or 1, move forward ARG - 1 lines first.  If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

;; remap C-a to `smarter-move-beginning-of-line'
(global-set-key [remap move-beginning-of-line]
                'my/smarter-move-beginning-of-line)
#+END_SRC

*** Hydra
clj-refactor needs Hydra, which I've been meaning to try.

#+begin_src emacs-lisp
  (use-package hydra)
#+end_src
** Writing
*** Lines.
Break text into visual lines, not logical.

#+begin_src emacs-lisp
  (remove-hook 'text-mode-hook #'turn-on-auto-fill)
  (add-hook 'text-mode-hook 'turn-on-visual-line-mode)
#+end_src

*** Markdown

I have projects where I need to use markdown.

#+begin_src emacs-lisp
  (use-package markdown-mode
    :mode (("\\`README\\.md'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode)))
#+end_src

*** Blog
For entering code snippets into my blog, but with the move to using Org mode,
it's not needed as much.

#+begin_src emacs-lisp
  (use-package htmlize)

  (defun htmlize-region-for-paste-css (beg end)
    "Htmlize the region and return just the HTML as a string.
  This forces the `inline-css' style and only returns the HTML
  body, but without the BODY tag.  This should make it useful for
  inserting the text to another HTML buffer."
    (let* ((htmlize-output-type 'css)
           (htmlbuf (htmlize-region beg end)))
      (unwind-protect
          (with-current-buffer htmlbuf
            (buffer-substring (plist-get htmlize-buffer-places 'content-start)
                              (plist-get htmlize-buffer-places 'content-end)))
        (kill-buffer htmlbuf))))

  (defun html-for-blog ()
    "Takes a region and returns it though htmlize."
    (interactive)
    (let* ((start (region-beginning))
           (end (region-end))
           (result (htmlize-region-for-paste-css start end))
           (htmlbuffer (generate-new-buffer "*code-html*")))
      (with-current-buffer htmlbuffer
        (insert result)
        (goto-char 1)
        (re-search-forward "<pre>\n")
        (replace-match "<pre class=\"src\"><code>")
        (re-search-forward "</pre>")
        (replace-match "</code></pre>")
        (clipboard-kill-ring-save (point-min) (point-max))
        (kill-buffer))))

#+end_src

*** Clean up Amazon URLs
Sometimes I reference Amazon URLs, so I'm going to use Steve Yegge's code to
make the URLs tidy. [[https://sites.google.com/site/steveyegge2/saving-time][Saving time]].

#+begin_src emacs-lisp
  (defun fix-amazon-url ()
    "Minimizes the Amazon URL under the point.  You can paste an Amazon
  URL out of your browser, put the cursor in it somewhere, and invoke
  this method to convert it."
    (interactive)
    (and (search-backward "http://www.amazon.com" (point-at-bol) t)
         (search-forward-regexp
    ".+/\\([A-Z0-9]\\{10\\}\\)/[^[:space:]\"]+" (point-at-eol) t)
         (replace-match
    (concat "http://www.amazon.com/o/asin/"
      (match-string 1)
      (match-string 3)))))
#+end_src

** Coding
*** Documentation
Make documentation available.

#+begin_src emacs-lisp
  (use-package helm-dash
    :init
    (setq helm-dash-docsets-path "~/.docset")
    (setq helm-dash-browser-func 'eww)
    :config
    (add-hook 'clojure-mode-hook (lambda () (setq-local helm-dash-docsets '("Clojure")))))
#+end_src

*** Subword
#+begin_src emacs-lisp
  (use-package subword
    :diminish " ⊚")
#+end_src

*** Tab width of 2 is compact and readable
#+begin_src emacs-lisp
  (setq-default tab-width 2)

  (defun luminous-setup-sh-mode ()
      "Personal preferences for shell scripts."
    (interactive)
    (setq sh-basic-offset 2)
    (setq sh-indentation 2)
    (flycheck-mode)
    (subword-mode))

  (add-hook 'sh-mode-hook 'luminous-setup-sh-mode)
#+end_src

*** New lines are always indented

I almost always want to go to the right indentation on the next line.
#+begin_src emacs-lisp
  (global-set-key (kbd "RET") 'newline-and-indent)
#+end_src

*** Don't use GNU style for C code.

#+begin_src emacs-lisp
  (setq c-default-style "linux"
        c-basic-offset 4)
#+end_src

*** Fix Java indenting

Lining on params is not fun in Java.

#+begin_src emacs-lisp
  (use-package google-c-style
    :defer t
    :config
    (add-hook 'c-mode-common-hook
              (lambda()
                (subword-mode)
                (google-set-c-style)
                (google-make-newline-indent)
                (setq c-basic-offset 4))))
#+end_src

*** Expand region

This is something I have to get the hang of too. It gradually expands the
selection. Handy for Emacs Lisp.

#+begin_src emacs-lisp
  (use-package expand-region
    :defer t
    :bind ("C-=" . er/expand-region))
#+end_src

*** Autocomplete

#+begin_src emacs-lisp
  (use-package company
    :diminish company-mode
    :commands company-mode
    :init (add-hook 'prog-mode-hook 'company-mode)
    :config
    (progn
      (defun indent-or-complete ()
        (interactive)
        (if (looking-at "\\_>")
            (company-complete-common)
          (indent-according-to-mode)))

      (global-set-key "\t" 'indent-or-complete)))
#+end_src

*** Highlight matching parens

#+begin_src emacs-lisp
  (setq blink-matching-paren nil)
  (show-paren-mode t)
  (setq show-paren-delay 0)
  (setq show-paren-style 'mixed)
#+end_src

*** Rainbow mode

Because I can't tell what a colour is by looking at the RGB values.

#+begin_src emacs-lisp
  (use-package rainbow-mode
    :diminish rainbow-mode
    :config
    (add-hook 'text-mode-hook 'rainbow-mode))
#+end_src

*** Smartparens

When you get used to it you can't live without, especially lisp code.

#+begin_src emacs-lisp
  (use-package smartparens
    :diminish " ⚖"
    :config
    (progn
      (use-package smartparens-config :ensure f)
      (setq sp-highlight-pair-overlay nil)

      (define-key sp-keymap (kbd "M-k") #'sp-raise-sexp)

      (define-key sp-keymap (kbd "C-(") #'sp-forward-slurp-sexp)
      (define-key sp-keymap (kbd "C-{") #'sp-forward-barf-sexp)

      (sp-with-modes `(c-mode c++-mode js-mode java-mode clojure-mode clojurescript-mode))

      (sp-pair "(" ")" :wrap "M-(")
      (sp-pair "{" "}" :wrap "M-{")
      (sp-pair "[" "]" :wrap "M-[")

      ;; Use it everywhere
      (smartparens-global-strict-mode t)
      (show-smartparens-global-mode t)))
#+end_src

*** Spelling

I'm Australian mate, so we use the British dictionary.

#+begin_src emacs-lisp
  (use-package flyspell
    :diminish " ⓒ"
    :config
    (progn
      (setq ispell-program-name "aspell"
            ispell-dictionary "british"
            ispell-extra-args '("--sug-mode=ultra")
            ispell-silently-savep t)
      (add-hook 'ispell-initialize-spellchecker-hook
                (lambda ()
                  (setq ispell-base-dicts-override-alist
                        '((nil ; default
                           "[A-Za-z]" "[^A-Za-z]" "[']" t
                           ("-d" "en_GB" "--encoding=utf-8") nil utf-8)
                          ("australian"
                           "[A-Za-z]" "[^A-Za-z]" "[']" t
                           ("-d" "en_AU" "--encoding=utf-8") nil utf-8)
                          ("american" ; Yankee English
                           "[A-Za-z]" "[^A-Za-z]" "[']" t
                           ("-d" "en_US" "--encoding=utf-8") nil utf-8)
                          ("british" ; British English
                           "[A-Za-z]" "[^A-Za-z]" "[']" t
                           ("-d" "en_GB" "--encoding=utf-8") nil utf-8)))))

      (add-hook 'text-mode-hook 'flyspell-mode)
      (add-hook 'prog-mode-hook 'flyspell-prog-mode)))
#+end_src

*** Whitespace

#+begin_src emacs-lisp
  (use-package ethan-wspace
    :diminish " ☐"
    :commands global-ethan-wspace-mode
    :init
    (progn
      (global-ethan-wspace-mode)
      (setq require-final-newline nil)
      (setq mode-require-final-newline nil)))
#+end_src

*** Tabs
Tab indentation is a disease; a cancer of this planet.

#+begin_src emacs-lisp
  (set-default 'indent-tabs-mode nil)
#+end_src

*** New lines are always indented
#+begin_src emacs-lisp
  (global-set-key (kbd "RET") 'newline-and-indent)
#+end_src

*** Kill back to indentation
From [[https://github.com/purcell/emacs.d/blob/master/lisp/init-editing-utils.el]]

#+begin_src emacs-lisp
  (defun sanityinc/kill-back-to-indentation ()
    "Kill from point back to the first non-whitespace character on the line."
    (interactive)
    (let ((prev-pos (point)))
      (back-to-indentation)
      (kill-region (point) prev-pos)))

  (bind-key "C-M-<backspace>" 'sanityinc/kill-back-to-indentation)
#+end_src

*** Snippets

#+begin_src emacs-lisp
  (use-package yasnippet
    :diminish (yas-minor-mode . " Ⓨ")
    :commands (yas-global-mode yas-minor-mode)
    :config
    (progn
      (yas-global-mode 1)))
#+end_src

*** Clojure
#+begin_src emacs-lisp
    (use-package clojure-mode
      :mode (("\\.clj\\'" . clojure-mode)
             ("\\.cljs\\'" . clojurescript-mode)
             ("\\.cljc$" . clojure-mode))
      :init
      (progn
        (use-package cider
          :init
          (progn
            (add-hook 'cider-mode-hook 'eldoc-mode)
            (add-hook 'cider-repl-mode-hook 'subword-mode))
          :config
          (setq nrepl-log-messages t
                cider-popup-stacktraces-in-repl t
                cider-repl-display-in-current-window t
                cider-repl-use-clojure-font-lock t
                cider-prompt-save-file-on-load 'always-save
                cider-font-lock-dynamically '(macro core function var)
                nrepl-hide-special-buffers t
                cider-overlays-use-font-lock t)
          (cider-repl-toggle-pretty-printing))

        (setq clojure--prettify-symbols-alist
              '(("fn" . ?λ)
                ("not=" . ?≠)
                ("identical?" . ?≡)
                ("<=" . ?≤)
                (">=" . ?≥)
                ("->" . (?- (Br . Bc) ?- (Br . Bc) ?>))
                ("->>" .  (?\s (Br . Bl) ?\s (Br . Bl) ?\s
                                 (Bl . Bl) ?- (Bc . Br) ?- (Bc . Bc) ?>
                                 (Bc . Bl) ?- (Br . Br) ?>))))

        (add-hook 'clojure-mode-hook 'prettify-symbols-mode)

        (use-package clj-refactor
          :config
          (clj-refactor-mode 1)
          (yas-minor-mode 1)
          (cljr-add-keybindings-with-prefix "C-c C-m"))))
#+end_src
**** 4Clojure
For Clojure practice.

#+begin_src emacs-lisp
  (use-package 4clojure)

  (defun endless/4clojure-check-and-proceed ()
    "Check the answer and show the next question if it worked."
    (interactive)
    (unless
        (save-excursion
          ;; Find last sexp (the answer).
          (goto-char (point-max))
          (forward-sexp -1)
          ;; Check the answer.
          (cl-letf ((answer
                     (buffer-substring (point) (point-max)))
                    ;; Preserve buffer contents, in case you failed.
                    ((buffer-string)))
            (goto-char (point-min))
            (while (search-forward "__" nil t)
              (replace-match answer))
            (string-match "failed." (4clojure-check-answers))))
      (4clojure-next-question)))

  (defadvice 4clojure/start-new-problem
      (after endless/4clojure/start-new-problem-advice () activate)
    ;; Prettify the 4clojure buffer.
    (goto-char (point-min))
    (forward-line 2)
    (forward-char 3)
    (fill-paragraph)
    ;; Position point for the answer
    (goto-char (point-max))
    (insert "\n\n\n")
    (forward-char -1)
    ;; Define our key.
    (local-set-key (kbd "M-j") #'endless/4clojure-check-and-proceed))
#+end_src
**** ClojureScript
Quick function for connecting to a figwheel session.

#+begin_src emacs-lisp
  (setq cider-cljs-lein-repl "(do (use 'figwheel-sidecar.repl-api) (start-figwheel!) (cljs-repl))")
#+end_src

*** Ocaml
#+begin_src emacs-lisp
  (load "tuareg/tuareg-site-file")
#+end_src
*** Flycheck
Error check anything I can.

#+begin_src emacs-lisp
  (use-package flycheck
    :commands flycheck-mode
    :diminish " Ⓕ"
    :defer t
    :config
    (progn

      ;; color mode line faces
      (defun monkey/defface-flycheck-mode-line-color (state)
        "Define a face for the given Flycheck STATE."
        (let* ((fname (intern (format "monkey-mode-line-flycheck-%s-face"
                                      (symbol-name state))))
               (foreground (face-foreground
                            (intern (format "flycheck-fringe-%s" state)))))
          (eval `(defface ,fname '((t ()))
                   ,(format "Color for Flycheck %s feedback in mode line."
                            (symbol-name state))
                   :group 'monkey))
          (set-face-attribute fname nil
                              :foreground foreground
                              :box (face-attribute 'mode-line :box))))

      (defun monkey/set-flycheck-mode-line-faces ()
        "Define or set the flycheck info mode-line faces."
        (mapcar 'monkey/defface-flycheck-mode-line-color
                '(error warning info)))
      (monkey/set-flycheck-mode-line-faces)

      (defmacro monkey/custom-flycheck-lighter (error)
        "Return a formatted string for the given ERROR (error, warning, info)."
        `(let* ((error-counts (flycheck-count-errors
                               flycheck-current-errors))
                (errorp (flycheck-has-current-errors-p ',error))
                (err (or (cdr (assq ',error error-counts)) "?"))
                (running (eq 'running flycheck-last-status-change)))
           (if (or errorp running) (format "•%s " err))))

      ;; Custom fringe indicator
      (when (fboundp 'define-fringe-bitmap)
        (define-fringe-bitmap 'my-flycheck-fringe-indicator
          (vector #b00000000
                  #b00000000
                  #b00000000
                  #b00000000
                  #b00000000
                  #b00000000
                  #b00000000
                  #b00011100
                  #b00111110
                  #b00111110
                  #b00111110
                  #b00011100
                  #b00000000
                  #b00000000
                  #b00000000
                  #b00000000
                  #b01111111)))

      (flycheck-define-error-level 'error
                                   :overlay-category 'flycheck-error-overlay
                                   :fringe-bitmap 'my-flycheck-fringe-indicator
                                   :fringe-face 'flycheck-fringe-error)

      (flycheck-define-error-level 'warning
                                   :overlay-category 'flycheck-warning-overlay
                                   :fringe-bitmap 'my-flycheck-fringe-indicator
                                   :fringe-face 'flycheck-fringe-warning)

      (flycheck-define-error-level 'info
                                   :overlay-category 'flycheck-info-overlay
                                   :fringe-bitmap 'my-flycheck-fringe-indicator
                                   :fringe-face 'flycheck-fringe-info)

      ))
#+end_src

*** YAML
A project I'm working on needs me to edit YAML.
#+begin_src emacs-lisp
  (use-package yaml-mode
    :mode (("\\.yaml\\'" . yaml-mode)))
#+end_src

*** LaTex/ConText
#+begin_src emacs-lisp
  (use-package tex-site :ensure f)
#+end_src

*** Git

#+begin_src emacs-lisp
  (use-package magit
    :commands magit-get-top-dir
    :bind (("C-c g" . magit-status)
           ("C-c C-g l" . magit-file-log)
           ("C-c f" . magit-grep)))


#+end_src

*** Mercurial

#+begin_src emacs-lisp
  (use-package monky)
#+end_src

** Email
Gnus has it's own config (should it be moved here?)

Sending out SMTP, use local Postfix service.

#+begin_src emacs-lisp
  (setq smtpmail-smtp-server "localhost")
  (setq smtpmail-smtp-service 25)
#+end_src

Emacs can send mail without Gnus.

#+begin_src emacs-lisp
    (use-package dot-gnus
      :ensure f)

    (setq send-mail-function 'smtpmail-send-it)
#+end_src

OfflineIMAP

#+begin_src emacs-lisp
  (use-package offlineimap)
#+end_src

BBDB

#+begin_src emacs-lisp
  (use-package bbdb)
#+end_src

** EMMS

#+begin_src emacs-lisp
  (use-package emms-setup
    :ensure f
    :load-path "site-lisp/emms/lisp"
    :defer t
    :config
    (progn
      (emms-all)
      (emms-default-players)))
#+end_src


** Twitter

I use Twitter as well.

#+begin_src emacs-lisp
  (use-package twittering-mode
    :defer t
    :config
    (setq twittering-icon-mode t
          twittering-use-master-password t))
#+end_src

** Org Mode

Start to use org-mode for everything I can.

#+begin_src emacs-lisp
  (use-package org-plus-contrib)
#+end_src

#+begin_src emacs-lisp
  (use-package org
    :ensure t)
#+end_src

*** My files

Trying a new org-mode scheme for files.

| organiser.org | My main Org file             |
| work.org      | Work related notes and TODOs |
| people.org    | People-related tasks         |
| archive.org   | Archive (duh)                |
| projects.org  | Personal Project Tracking    |
| personal.org  | Personal Development         |

*** Modules
#+begin_src emacs-lisp
  (setq org-modules '(org-bbdb
                      org-gnus
                      org-info
                      org-habit
                      org-drill))

  (eval-after-load 'org
    '(org-load-modules-maybe t))
#+end_src

*** Use CSS for any HTML output

#+begin_src emacs-lisp
  (setq org-export-htmlize-output-type 'css)
#+end_src

*** Keyboard shortcuts

#+begin_src emacs-lisp
  (bind-key "C-c r" 'org-capture)
  (bind-key "C-c a" 'org-agenda)
  (bind-key "C-c l" 'org-store-link)
  (bind-key "C-c L" 'org-insert-link-global)
  (bind-key "C-c C-r" 'org-refile org-mode-map)
#+end_src

Allow for clock in via agenda mode.

#+begin_src emacs-lisp
  (eval-after-load 'org-agenda
    '(bind-key "i" 'org-agenda-clock-in org-agenda-mode-map))
#+end_src

**** Speed commands

 These are great for quickly acting on tasks.

 #+begin_src emacs-lisp
   (setq org-use-effective-time t)

   (defun my/org-use-speed-commands-for-headings-and-lists ()
     "Activate speed commands on list items too."
     (or (and (looking-at org-outline-regexp) (looking-back "^\**"))
         (save-excursion (and (looking-at (org-item-re)) (looking-back "^[ \t]*")))))
   (setq org-use-speed-commands 'my/org-use-speed-commands-for-headings-and-lists)

   (add-to-list 'org-speed-commands-user '("x" org-todo "DONE"))
   (add-to-list 'org-speed-commands-user '("y" org-todo-yesterday "DONE"))
   (add-to-list 'org-speed-commands-user '("s" call-interactively 'org-schedule))
   (add-to-list 'org-speed-commands-user '("i" call-interactively 'org-clock-in))
   (add-to-list 'org-speed-commands-user '("o" call-interactively 'org-clock-out))
   (add-to-list 'org-speed-commands-user '("$" call-interactively 'org-archive-subtree))
 #+end_src

*** Taking notes

My org files are shared on Dropbox, so they're synced between all the different
machines I use.

#+begin_src emacs-lisp
  (setq org-directory "~/Dropbox/GTD")
  (setq org-notes-file (concat org-directory "/organiser.org"))
  (setq org-work-file (concat org-directory "/work.org"))
  (setq org-people-file (concat org-directory "/people.org"))
  (setq org-journal-file (concat org-directory "/journal.org"))
  (setq org-projects-file (concat org-directory "/projects.org"))
  (setq org-personal-file (concat org-directory "/personal.org"))
  (setq org-woodworking-file (concat org-directory "/woodworking.org"))
#+end_src

*** Frequently accessed files
Registers allow you to jump to a file or other location quickly. To jump to a
register, use =C-x r j= followed by the letter of the register.

#+begin_src emacs-lisp
  (defvar my/refile-map (make-sparse-keymap))

  (defmacro my/defshortcut (key file)
    `(progn
       (set-register ,key (cons 'file ,file))
       (define-key my/refile-map
         (char-to-string ,key)
         (lambda (prefix)
           (interactive "p")
           (let ((org-refile-targets '(((,file) :maxlevel . 6)))
                 (current-prefix-arg (or current-prefix-arg '(4))))
             (call-interactively 'org-refile))))))

  (my/defshortcut ?i (expand-file-name "monkey.org" user-emacs-directory))
  (my/defshortcut ?o org-notes-file)
#+end_src

**** Templates

Use =org-capture= templates to add tasks quickly.

#+begin_src emacs-lisp
  (defvar my/org-basic-task-template "* TODO %^{Task}
    SCHEDULED: %^t
    :PROPERTIES:
    :Effort: %^{effort|1:00|0:05|0:15|0:30|2:00|4:00}
    :END:
    %?
  " "Basic task data")

  (defun capture-report-date-file (path)
    (let ((name (read-string "File Title: ")))
      (expand-file-name (format "%s-%s.org"
                                (format-time-string "%Y-%m-%d")
                                name) path)))

  (setq org-capture-templates
        `(("t" "Tasks" entry
           (file+headline org-notes-file "Tasks")
           ,my/org-basic-task-template)
          ("T" "Quick task" entry
           (file+headline org-notes-file "Tasks")
           "* TODO %^{Task}"
           :immediate-finish t)
          ("b" "Work task" entry
           (file+headline org-work-file "Tasks")
           ,my/org-basic-task-template)
          ("p" "People task" entry
           (file+headline org-people-file "Tasks")
           ,my/org-basic-task-template)
          ("j" "Journal entry" plain
           (file+datetree org-journal-file)
           "%K = %a\n%i\n%?\n"
           :unnarrowed t)
          ("B" "Blog Entry" plain
           (file (capture-report-date-file "~/Projects/monkey-blog/resources/posts/"))
           "#+title: %^{Title}
  ,#+date: %T\n\n%?"
           )
          ("m" "TODO from Mail" entry
           (file+headline org-notes-file "Tasks")
           "* TODO %?, Link: %a")))
#+end_src

**** Gnus e-mail tasks
When making a task based off an e-mail, I will archive the e-mail, be sure to
update the link so it points to the archived e-mail.

[[http://stackoverflow.com/questions/15736590/how-to-automatically-track-links-in-org-mode-to-gnus-messages][How to automatically track links in org mode]]

#+begin_src emacs-lisp
  (defun my/org-link-archved-mail ()
    (interactive)
    (goto-char 1)
    (let ((search-invisible t))
      (replace-string "INBOX" "org-archive")))

  (add-hook 'org-capture-before-finalize-hook 'my/org-link-archved-mail)
#+end_src

**** Refiling

=org-refile= lets you organize notes by typing in the headline to file them under.
#+begin_src emacs-lisp
  (setq org-reverse-note-order t)
  (setq org-refile-use-outline-path nil)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
  (setq org-refile-use-cache nil)
  (setq org-refile-targets '((org-agenda-files . (:maxlevel . 6))))
  (setq org-blank-before-new-entry nil)
#+end_src

*** Tasks
**** Managing tasks
***** Track TODO state

      The parentheses indicate keyboard shortcuts that I can use to set the task
      state. =@= and =!= toggle logging. =@= prompts you for a note, and =!=
      automatically logs the timestamp of the state change.

#+begin_src emacs-lisp
  (setq org-todo-keywords
        '((sequence
           "TODO(t)" ; next action
           "STARTED(s)"
           "WAITING(w@/!)"
           "SOMEDAY(.)" "|" "DONE(x!)" "CANCELLED(c@)")
          (sequence "TODELEGATE(-)" "DELEGATED(d)" "|" "COMPLETE(x)")))
#+end_src

*** Habits
    Starting to use org-habit.
#+begin_src emacs-lisp
  (setq org-habit-graph-column 60)
  (setq org-habit-show-habits-only-for-today nil)
#+end_src
*** Org agenda
**** Basic configuation

#+begin_src emacs-lisp
  (setq org-agenda-files
        (delq nil
              (mapcar (lambda (x) (and (file-exists-p x) x))
                      `(,org-notes-file
                        ,org-work-file
                        ,org-people-file
                        ,org-journal-file
                        ,org-projects-file
                        ,org-personal-file
                        ,org-woodworking-file))))
#+end_src

Look at two days at a time, see log entries, but not scheduled items that are
finished. Use a timegrid.

#+begin_src emacs-lisp
  (setq org-agenda-span 2)
  (setq org-agenda-sticky nil)
  (setq org-agenda-inhibit-startup t)
  (setq org-agenda-use-tag-inheritance t)
  (setq org-agenda-show-log t)
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled)
  (setq org-agenda-time-grid
        '((daily today require-timed)
          "----------------"
          (800 1000 1200 1400 1600 1800)))
  (setq org-columns-default-format "%50ITEM %12SCHEDULED %TODO %3PRIORITY %Effort{:} %TAGS")
#+end_src

**** Start weeks on a Saturday

This is something that Sacha does in her config, her reasoning for it makes
sense enough for me to try it: [[http://sachachua.com/blog/2010/11/week-beginnings/][week beginnings]].

#+begin_src emacs-lisp
  (setq org-agenda-start-on-weekday 6)
#+end_src
**** Custom commands

Experimenting with custom commands for org agenda.

| Key | Description                          |
| .   | What am I waiting for?               |
| o   | Show personal and misc tasks         |
| b   | Show work related tasks              |
| w   | Show all tasks for the upcoming week |

#+begin_src emacs-lisp
  (setq org-agenda-custom-commands
        `(("." "Waiting for" todo "WAITING")
          ("o" todo ""
           ((org-agenda-files `(,org-notes-file))))
          ("b" todo ""
           ((org-agenda-files `(,org-work-file))))
          ("w" "Weekly review" agenda ""
           ((org-agenda-span 7)
            (org-agenda-log-mode 1)))
          ("u" "Unscheduled tasks" tags-todo "-someday-TODO=\"SOMEDAY\"-TODO=\"DELEGATED\"-TODO=\"WAITING\"-project"
           ((org-agenda-skip-function 'my/org-agenda-skip-scheduled)
            (org-agenda-view-columns-initially t)
            (org-tags-exclude-from-inheritance '("project"))
            (org-agenda-overriding-header "Unscheduled TODO entries: ")
            (org-columns-default-format "%50ITEM %TODO %3PRIORITY %Effort{:} %TAGS")
            (org-agenda-sorting-strategy '(todo-state-up priority-down effort-up tag-up category-keep))))))
#+end_src

**** Make it easy to mark a task as done

Great for quickly going through the to-do list. Gets rid of one
extra keystroke. ;)

#+begin_src emacs-lisp
  (defun my/org-agenda-done (&optional arg)
    "Mark current TODO as done.
  This changes the line at point, all other lines in the agenda referring to
  the same tree node, and the headline of the tree node in the Org-mode file."
    (interactive "P")
    (org-agenda-todo "DONE"))
  ;; Override the key definition for org-exit
  (eval-after-load 'org-agenda
    '(define-key org-agenda-mode-map "x" 'my/org-agenda-done))
#+end_src

**** Make it easy to mark a task as done and create a follow-up task

#+begin_src emacs-lisp
    (defun my/org-agenda-mark-done-and-add-followup ()
      "Mark the current TODO as done and add another task after it.
  Creates it at the same level as the previous task, so it's better to use
  this with to-do items than with projects or headings."
      (interactive)
      (org-agenda-todo "DONE")
      (org-agenda-switch-to)
      (org-capture 0 "t"))
  ;; Override the key definition
  (eval-after-load 'org-agenda
    '(define-key org-agenda-mode-map "X" 'my/org-agenda-mark-done-and-add-followup))
#+end_src

**** Capture something based on the agenda

#+begin_src emacs-lisp
  (defun my/org-agenda-new ()
    "Create a new note or task at the current agenda item.
  Creates it at the same level as the previous task, so it's better to use
  this with to-do items than with projects or headings."
    (interactive)
    (org-agenda-switch-to)
    (org-capture 0))
  ;; New key assignment
  (eval-after-load 'org-agenda
    '(define-key org-agenda-mode-map "N" 'my/org-agenda-new))
#+end_src

*** Archiving

From http://stackoverflow.com/questions/6997387/how-to-archive-all-the-done-tasks-using-a-single-command
#+begin_src emacs-lisp
(defun my/org-archive-done-tasks ()
  "Archive finished or cancelled tasks."
  (interactive)
  (org-map-entries
   (lambda ()
     (org-archive-subtree)
     (setq org-map-continue-from (outline-previous-heading)))
   "TODO=\"DONE\"|TODO=\"CANCELLED\"" (if (org-before-first-heading-p) 'file 'tree)))
#+end_src

*** Enable Org Lists and Tables to email
    http://pragmaticemacs.com/emacs/use-org-mode-tables-and-structures-in-emails-and-elsewhere/
#+begin_src emacs-lisp
  (add-hook 'message-mode-hook 'turn-on-orgtbl)
  (add-hook 'message-mode-hook 'turn-on-orgstruct++)
#+end_src
*** Templates
**** Structure Templates
#+begin_src emacs-lisp
  (setq org-structure-template-alist
        '(("l" "#+begin_src emacs-lisp\n?\n#+end_src" "<src lang=\"emacs-lisp\">\n?</src>")))
#+end_src
** Terminal
Try to use Emacs for my terminal.

#+begin_src emacs-lisp
  (use-package multi-term
    :config
    (global-set-key (kbd "C-c m") 'multi-term-next)
    (add-hook 'term-mode-hook (lambda()
                                (yas-minor-mode -1))))
#+end_src
** Graphviz
I use Grapviz sometimes.

#+begin_src emacs-lisp
  (use-package graphviz-dot-mode)
#+end_src
