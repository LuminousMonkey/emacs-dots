#+title: Mike Aldred's Emacs configuration.
#+author: Mike Aldred

* Configuration
:PROPERTIES:
:VISIBILITY: children
:END:

** About this file
 This is my actual Emacs configuration. Back to using Org-mode.

** Personal Information
 #+begin_src emacs-lisp
   (setq user-full-name "Mike Aldred"
	 user-mail-address "mike.aldred@luminousmonkey.org")
 #+end_src

** Emacs Initialisation
*** Settings
Disable certain byte compiler warnings to cut down on the noise. This is a personal choice and can be removed if you would like to see any and all byte compiler warnings.

#+begin_src emacs-lisp
  (setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))
#+end_src
*** Sane Defaults
Just some defaults that I consider to be sane for basic operations.
#+begin_src emacs-lisp
  ;; enable y/n answers
  (fset 'yes-or-no-p 'y-or-n-p)

  ;; Make the selection work like most people expect.
  (delete-selection-mode t)
  (transient-mark-mode t)

  (setq create-lockfiles nil)

  ; Make sure we always use UTF-8.
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)

  ;; Automatically save buffers before launching M-x compile and friends,
  ;; instead of asking you if you want to save.
  (setq compilation-ask-about-save nil)

  ;; Make compilation buffers scroll to follow the output, but stop scrolling
  ;; at the first error.
  (setq compilation-scroll-output 'first-error)

  (setq-default
   mac-option-modifier 'meta		    ; Fix Mac Alt handling
   auto-window-vscroll nil		    ; Lighten vertical scroll
   cursor-in-non-selected-windows nil         ; Hide the cursor in inactive windows
   display-time-default-load-average nil	    ; Don't display load average
   display-time-format "%H:%M"		    ; Format the time string
   fill-column 80			            ; Set width for automatic line breaks
   help-window-select t		            ; Focus new help windows when opened
   indent-tabs-mode nil		            ; Stop using tabs to indent
   mouse-yank-at-point t		            ; Yank at point rather than pointer
   ns-use-srgb-colorspace nil		    ; Don't use sRGB colors
;;   recenter-positions '(5 top bottom)	    ; Set re-centering positions
   scroll-conservatively most-positive-fixnum ; Always scroll by one line
   scroll-margin 10                           ; Add a margin when scrolling vertically
   select-enable-clipboard t                  ; Merge system's and Emacs' clipboard
   sentence-end-double-space nil              ; End a sentence after a dot and a space
   show-trailing-whitespace nil	            ; Display trailing whitespaces
   split-height-threshold nil                 ; Disable vertical window splitting
   split-width-threshold nil                  ; Disable horizontal window splitting
   tab-width 4                                ; Set width for tabs
   uniquify-buffer-name-style 'forward        ; Uniquify buffer names
;;   window-combination-resize t                ; Resize windows proportionally
   x-stretch-cursor t                         ; Stretch cursor to the glyph width
   )

  (display-time-mode 1)

                                          ; Home directory always
  (cd "~/")

                                          ; Iterate through CamelCase words
  (global-subword-mode 1)

  (put 'downcase-region 'disabled nil)              ; Enable downcase-region
  (put 'upcase-region 'disabled nil)                ; Enable upcase-region

  ;; Garbage collect on focus-out, Emacs /should/ feel snappier.
  (add-hook 'focus-out-hook #'garbage-collect)

  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src
*** Initial Keybindings
Initial keybindings that I want fairly early in the config, because I'm used to them.
#+begin_src emacs-lisp
  (define-key global-map (kbd "C-x C-m") 'execute-extended-command)
  (define-key global-map (kbd "C-w ") 'backward-kill-word)
  (define-key global-map (kbd "C-x C-k") 'kill-region)
  (define-key global-map (kbd "C-c C-k") 'kill-region)
#+end_src
** Appearance
*** Basic appearance
Remove the toolbar and the scrollbar, keep the menu though, I might discover new features I didn't know.
#+begin_src emacs-lisp
  (dolist (mode '(tool-bar-mode scroll-bar-mode))
    (when (fboundp mode) (funcall mode -1)))

  (setq-default
   inhibit-startup-screen t
   initial-scratch-message "")
#+end_src
*** Font
#+begin_src emacs-lisp
  (use-package dynamic-fonts
    :config
    (progn
      (setq dynamic-fonts-preferred-monospace-point-size 16
            dynamic-fonts-preferred-proportional-point-size 20
            dynamic-fonts-preferred-monospace-fonts
            (-union '("Fira Code Medium") dynamic-fonts-preferred-monospace-fonts)
            dynamic-fonts-preferred-proportional-fonts
            (-union '("ETBookOT") dynamic-fonts-preferred-proportional-fonts))
      (dynamic-fonts-setup)))
#+end_src

*** Theme
I like to get into the theme as quickly as possible, if something goes wrong, I want my font, and my colours.

#+begin_src emacs-lisp
  (use-package doom-themes
    :demand t
    :custom
    (doom-themes-enable-bold t)
    (doom-themes-enable-italic t)
    :config
    (load-theme 'doom-one-light t)
    (doom-themes-visual-bell-config)
    (doom-themes-org-config)
    (with-eval-after-load 'flycheck
      (set-face-attribute 'flycheck-error nil :underline `(:color ,(doom-color 'error) :style line))
      (set-face-attribute 'flycheck-info nil :underline `(:color ,(doom-color 'highlight) :style line))
      (set-face-attribute 'flycheck-info nil :underline `(:color ,(doom-color 'highlight) :style line))
      (set-face-attribute 'flycheck-warning nil :underline `(:color ,(doom-color 'warning) :style line))))
#+end_src
*** Modeline
#+begin_src emacs-lisp
  (use-package doom-modeline
    :ensure t
    :hook (after-init . doom-modeline-mode))
#+end_src
*** Highlights
#+begin_src emacs-lisp
  (use-package volatile-highlights
    :blackout volatile-highlights-mode
    :config
    (volatile-highlights-mode +1))
#+end_src
** Client Settings
I use an Emacs daemon, so some settings don't get set on the client from the Emacs server startup. So we define a function here that will run when a client starts to get it setup.

#+begin_src emacs-lisp
  (defun luminousmonkey/run-client-settings (&rest frame)
    (if (window-system)
        (progn
          (dynamic-fonts-setup)
          (setq doom-modeline-icon (display-graphic-p)))))

    (require 'server)

    (defadvice server-create-window-system-frame
        (after set-window-system-frame-colours ())
      "Set custom font, etc, when we create the first frame on display"
      (message "Running after frame-initialize")
      (luminousmonkey/run-client-settings))

    (ad-activate 'server-create-window-system-frame)
    (add-hook 'after-make-frame-functions 'luminousmonkey/run-client-settings)
#+end_src
** Navigation
*** Navigation / Inline
Smarter =C-a=.

#+begin_src emacs-lisp
  (defun monkey/beginning-of-line-dwim ()
    "Move point to first non-whitespace character, or beginning of line."
    (interactive "^")
    (let ((origin (point)))
      (beginning-of-line)
      (and (= origin (point))
           (back-to-indentation))))

  (global-set-key [remap move-beginning-of-line] #'monkey/beginning-of-line-dwim)
#+end_src
*** Navigation / Replace
=anzu= has a nice feedback on regexp matches.

#+begin_quote
=anzu.el= is an Emacs port of
[[https://github.com/osyo-manga/vim-anzu][anzu.vim]]. =anzu.el= provides a minor
mode which displays /current match/ and /total matches/ information in the
mode-line in various search modes.

[[https://github.com/syohex/emacs-anzu][Syohei Yoshida]]
#+end_quote

#+begin_src emacs-lisp
  (use-package anzu
    :blackout
    :bind
    ([remap query-replace] . anzu-query-replace-regexp)
    :hook
    (after-init . global-anzu-mode)
    :custom
    (anzu-cons-mode-line-p nil))
#+end_src
*** Navigation / Search
Isearch stands for /incremental search/. This means that search results are highlighted while you are typing your query, incrementally. Since he who can do more can do less, I've replaced default bindings with the regexp-equivalent commands.

#+BEGIN_SRC emacs-lisp
  (use-package isearch
    :ensure nil
    :straight f
    :bind
    (("C-S-r" . isearch-backward-regexp)
     ("C-S-s" . isearch-forward-regexp)
     :map isearch-mode-map
     ("<M-down>" . isearch-ring-advance)
     ("<M-up>" . isearch-ring-retreat)
     :map minibuffer-local-isearch-map
     ("<M-down>" . next-history-element)
     ("<M-up>" . previous-history-element))
    :init
    (setq-default
     isearch-allow-scroll t
     lazy-highlight-cleanup nil
     lazy-highlight-initial-delay 0))
#+END_SRC
*** Key chords
Key chords allows you to press two keys in quick succession to run a command.
#+begin_src emacs-lisp
  (use-package use-package-chords
    :config (key-chord-mode 1))

  (require 'use-package-chords)
#+end_src
*** Line and word jumping
#+begin_src emacs-lisp
  (use-package avy
    :demand t
    :chords (("jj" . avy-goto-word-1)
             ("jl" . avy-goto-line))
    :bind (("C-:" . avy-goto-char))
    :config
    (setq avy-keys
          (nconc (number-sequence ?a ?z)
                 (number-sequence ?A ?Z)
                 (number-sequence ?1 ?9)
                 '(?0)))
    (setq avy-all-windows 'all-frames)
    (with-eval-after-load "isearch"
      (define-key isearch-mode-map (kbd "C-;") 'avy-isearch)))
#+end_src
*** Beacon
Show where the cursor has moved to.
#+begin_src emacs-lisp
  (use-package beacon
    :blackout beacon-mode
    :custom
    (beacon-push-mark 10)
    :config
    (beacon-mode +1))
#+end_src
** Parentheses
Highlight parenthese-like delimiters in a rainbow fashion. It ease the reading when dealing with mismatched parentheses.
#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

#+begin_src emacs-lisp
  (use-package smartparens
    :blackout " âš–"
    :bind
    (("M-<backspace>" . sp-unwrap-sexp)
     ("M-<left>" . sp-forward-barf-sexp)
     ("M-<right>" . sp-forward-slurp-sexp)
     ("M-S-<left>" . sp-backward-slurp-sexp)
     ("M-S-<right>" . sp-backward-barf-sexp)
     ("M-k" . sp-raise-sexp))
    :hook
    (after-init . smartparens-global-mode)
    :custom
    (sp-highlight-pair-overlay nil)
    (sp-highlight-wrap-overlay nil)
    (sp-highlight-wrap-tag-overlay nil)
    :config
    (progn
      (sp-pair "(" ")" :wrap "M-(")
      (sp-pair "{" "}" :wrap "M-{")
      (sp-pair "[" "]" :wrap "M-[")
      (require 'smartparens-config)))
#+end_src

Be sure to highlight matching parens
#+begin_src emacs-lisp
  (setq show-paren-style 'paren
        show-paren-delay 0.03
        show-paren-highlight-openparen t
        show-paren-when-point-inside-paren nil
        show-paren-when-point-in-periphery t)

  (show-paren-mode 1)
#+end_src
** Point and Region
Increase region by semantic units. It tries to be smart about it and adapt to
the structure of the current major mode.

#+begin_src emacs-lisp
(use-package expand-region
  :bind
  ("C-+" . er/contract-region)
  ("C-=" . er/expand-region))
#+end_src

Persistent highlighting.

#+begin_src emacs-lisp
(use-package highlight)
#+end_src
** Languages
*** Clojure
#+begin_src emacs-lisp
  (use-package clojure-mode
    :mode (("\\.edn$" . clojure-mode))
    :init
    (progn
      (use-package clojure-snippets)
      (use-package clojure-mode-extra-font-locking)
      (use-package cider
        :diminish " Ã§"
        :init
        (progn
          (add-hook 'cider-mode-hook 'eldoc-mode)
          (add-hook 'cider-repl-mode-hook 'subword-mode))
        :config
        (progn
          (setq nrepl-log-messages t
                cider-popup-stacktraces-in-repl t
                cider-repl-display-in-current-window t
                cider-repl-use-clojure-font-lock nil
                cider-prompt-save-file-on-load 'always-save
                cider-font-lock-dynamically '(macro core function var)
                nrepl-hide-special-buffers t
                cider-overlays-use-font-lock t
                clojure-use-backtracking-indent t
                cider-repl-history-file (expand-file-name "nrepl-history" user-emacs-directory)
                cider-auto-select-error-buffer nil
                cider-prompt-save-file-on-load nil
                cider-repl-use-pretty-printing t
                cider-repl-display-help-banner nil)
          (add-to-list 'same-window-buffer-names "*cider*")))

      (setq clojure--prettify-symbols-alist
            '(("fn" . ?Î»)
              ("not=" . ?â‰ )
              ("identical?" . ?â‰¡)
              ("<=" . ?â‰¤)
              (">=" . ?â‰¥)
              ("->" . (?- (Br . Bc) ?- (Br . Bc) ?>))
              ("->>" .  (?\s (Br . Bl) ?\s (Br . Bl) ?\s
                             (Bl . Bl) ?- (Bc . Br) ?- (Bc . Bc) ?>
                             (Bc . Bl) ?- (Br . Br) ?>))))

      (add-hook 'clojure-mode-hook 'prettify-symbols-mode)
      (add-hook 'cider-repl-mode-hook '(lambda () (setq scroll-conservatively 101)))

      (use-package flycheck-clojure
        :init
        (progn
          (eval-after-load 'flycheck '(flycheck-clojure-setup))))))
#+end_src
*** BBDB
#+begin_src emacs-lisp
  (use-package bbdb
    :custom
    (bbdb-file "~/Dropbox/bbdb"))
#+end_src
*** Org
Probably the best thing about Emacs.
#+begin_src emacs-lisp
  (use-package org
    :bind
    (("C-c c" . org-capture)
     ("C-c a" . org-agenda)
     ("C-c l" . org-store-link))
    :custom
    (org-export-htmlize-output-type 'css)
    (org-src-fontify-natively t)
    (org-src-window-setup 'current-window)
    (org-babel-load-languages
     '((emacs-lisp . t)
       (R . t)))
    (org-confirm-babel-evaluate nil)
    (org-latex-pdf-process
     (list "latexmk -pdflatex=xelatex -shell-escape -bibtex -f -pdf %f"))
    (org-latex-with-hyperref nil)
    (org-agenda-span 2)
    (org-agenda-sticky nil)
    (org-agenda-inhibit-startup t)
    (org-agenda-use-tag-inheritance t)
    (org-agenda-show-log t)
    (org-agenda-skip-scheduled-if-done t)
    (org-agenda-skip-deadline-if-done t)
    (org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled)
    (org-agenda-time-grid
     '((daily today require-timed)
       (800 1000 1200 1400 1600 1800)
       "......" "----------------"))
    (org-columns-default-format
     "%50ITEM %12SCHEDULED %TODO %3PRIORITY %Effort{:} %TAGS")
    (org-modules '(org-bbdb
                   org-habit))
    :config
    (eval-after-load 'org-agenda
      '(bind-key "i" 'org-agenda-clock-in org-agenda-mode-map))
    (require 'org-habit))

  (eval-after-load 'org
    '(org-load-modules-maybe t))

  (add-hook 'org-mode-hook 'visual-line-mode)

  (setq org-directory "~/Dropbox/GTD"
        org-inbox-file (concat org-directory "/inbox.org")
        org-projects-file (concat org-directory "/projects.org")
        org-someday-file (concat org-directory "/someday.org")
        org-tickler-file (concat org-directory "/tickler.org"))

  (setq org-global-properties '(("Effort_ALL" . "1:00 0:02 0:05 0:15 0:30 2:00 4:00")))

  (defvar monkey/org-basic-task-template "* TODO %^{Task}
    :PROPERTIES:
    :Effort: %^{Effort}p
    :END:
    %?
  " "Basic task data")

  (setq org-capture-templates
        `(("t" "Tasks" entry
           (file+headline org-inbox-file "Tasks")
           ,monkey/org-basic-task-template)
          ("q" "Quick Task" entry
           (file+headline org-inbox-file "Tasks")
           "* TODO %^{Task}\n :PROPERTIES:\n :CREATED: %U\n:END:"
           :immediate-finish t)
          ("T" "Tickler" entry
           (file+headline org-tickler-file "Tickler")
           "* %i%? \n :PROPERTIES:\n :CREATED: %U\n:END:")))

  (setq org-log-done 'time)
  (setq org-log-into-drawer t)
  (setq org-log-state-notes-insert-after-drawers nil)

  (setq org-tag-alist (quote (("@errand" . ?e)
                              ("@office" . ?o)
                              ("@home" . ?h)
                              ("@email" . ?E)
                              ("@phone" . ?p))))

  (setq org-todo-keywords '((sequence "TODO(t)" "WAITING(w)" "|" "DONE(d)" "CANCELLED(c)")))

  (defun org-archive-done-tasks ()
    (interactive)
    (org-map-entries 'org-archive-subtree "/DONE" 'file))

  (require 'find-lisp)
  (setq org-agenda-files '(org-inbox-file org-projects-file org-tickler-file))

  (setq org-agenda-files
        (delq nil
              (mapcar (lambda (x) (and (file-exists-p x) x))
                      `(,org-inbox-file
                        ,org-projects-file
                        ,org-tickler-file))))

  (setq org-refile-targets `((,org-projects-file :maxlevel . 3)
                             (,org-someday-file :level . 1)
                             (,org-tickler-file :maxlevel . 2)))

  (setq org-agenda-custom-commands
        '(("z" "Super View"
           ((agenda "" ((org-agenda-span 'day)
                        (org-super-agenda-groups
                         '((:name "Today"
                                  :time-grid t
                                  :date today
                                  :todo "TODAY"
                                  :scheduled today
                                  :order 1)
                           (:name "Due Today"
                                  :deadline today)
                           (:name "Due Soon"
                                  :deadline future)
                           (:name "Habits"
                                  :habit t)))))
            (alltodo "" ((org-agenda-overriding-header "")
                         (org-agenda-skip-function #'my-org-agenda-skip-all-siblings-but-first)
                         (org-super-agenda-groups
                          '((:name "Projects" :and (:category "projects" :children nil))
                            (:discard (:anything t))))))
            (alltodo "" ((org-agenda-overriding-header "")
                         (org-super-agenda-groups
                          '((:name "Important"
                                   :priority "A")
                            (:name "Quick Picks"
                                   :effort< "0:05")
                            (:name "Waiting..."
                                   :todo "WAITING"
                                   :order 98)
                            (:discard (:anything t))))))))
          ("o" "At the office" tags-todo "@office"
           ((org-agenda-overriding-header "Office")
            (org-agenda-skip-function #'my-org-agenda-skip-all-siblings-but-first)))))

  (defun my-org-agenda-skip-all-siblings-but-first ()
    "Skip all but the first non-done entry."
    (let (should-skip-entry)
      (unless (org-current-is-todo)
        (setq should-skip-entry t))
      (save-excursion
        (while (and (not should-skip-entry) (org-goto-sibling t))
          (when (org-current-is-todo)
            (setq should-skip-entry t))))
      (when should-skip-entry
        (or (outline-next-heading)
            (goto-char (point-max))))))

  (defun org-current-is-todo ()
    (string= "TODO" (org-get-todo-state)))

  (use-package org-download
    :after org
    :bind
    (:map org-mode-map
          (("s-Y" . org-download-screenshot)
           ("s-y" . org-download-yank)))
    :config
    (if (memq window-system '(mac ns))
        (setq org-download-screenshot-method "screencapture -i %s")
      (setq org-download-screenshot-method "maim -s %s"))
    (defun monkey/org-download-method (link)
      "This is a helper function for org-download.
    It creates a folder in the root directory (~/.org/img/) named after the
    org filename (sans extension) and puts all images from that file in there.
    Inspired by https://github.com/daviderestivo/emacs-config/blob/6086a7013020e19c0bc532770e9533b4fc549438/init.el#L701"
      (let ((filename
             (file-name-nondirectory
              (car (url-path-and-query
                    (url-generic-parse-url link)))))
            ;; Create folder name with current buffer name, and place in root dir
            (dirname (concat "./images/"
                             (replace-regexp-in-string " " "_" (downcase (file-name-base buffer-file-name))))))

        ;; Add timestamp to filename
        (setq filename-with-timestamp (format "%s%s.%s"
                                              (file-name-sans-extension filename)
                                              (format-time-string org-download-timestamp)
                                              (file-name-extension filename)))
        ;; Create folder if necessary
        (unless (file-exists-p dirname)
          (make-directory dirname))
        (expand-file-name filename-with-timestamp dirname)))
    (setq org-download-method 'monkey/org-download-method))
#+end_src

Use a better Org Agenda layout
#+begin_src emacs-lisp
  (use-package org-super-agenda
    :demand
    :after org
    :config
    (org-super-agenda-mode t)
    (setq org-super-agenda-groups
          '((:name "Today"
                   :time-grid t
                   :date today
                   :todo "TODAY"
                   :scheduled today
                   :order 1)
            (:name "Important"
                   :priority "A")
            (:name "Quick Picks"
                   :effort< "0:05")
            (:name "Overdue"
                   :deadline past)
            (:name "Projects"
                   :tag "@office")
            (:name "Waiting..."
                   :todo "WAITING"
                   :order 98))))
#+end_src

Frequently accessed files.
#+begin_src emacs-lisp
  (defvar monkey/refile-map (make-sparse-keymap))

  (defmacro monkey/defshortcut (key file)
    `(progn
       (set-register ,key (cons 'file ,file))
       (define-key monkey/refile-map
         (char-to-string ,key)
         (lambda (prefix)
           (interactive "p")
           (let ((org-refile-targets '(((,file) :maxlevel . 6)))
                 (current-prefix-arg (or current-prefix-arg '(4))))
             (call-interactively 'org-refile))))))

  (monkey/defshortcut ?i (expand-file-name "monkey.org" user-emacs-directory))
#+end_src
*** Org Holiday Setup
#+begin_src emacs-lisp
  ;; Some Australian holidays go to the next Monday if on a weekend.
  (defun next-week-day-holiday (in-day in-month)
    (let* ((holiday-date (list in-month in-day year))
           (current-day (calendar-day-of-week holiday-date)))
      (if (or (= 6 current-day) (= 0 current-day))
          (+ (1+ (mod current-day 5))
             (calendar-absolute-from-gregorian holiday-date))
        (calendar-absolute-from-gregorian holiday-date))))

  ;; Australia Public Holidays
  (setq holiday-local-holidays
        '((holiday-fixed 1 1     "New Years Day")
          ;; (holiday-sexp '(next-week-day-holiday 1 1)
          ;;               "New Years Day Holiday")
          (holiday-fixed 1 26    "Australia Day")
          ;; (holiday-sexp '(next-week-day-holiday 26 1)
          ;;               "Australia Day Holiday")
          (holiday-float 3 1 1     "Labour Day")
          (holiday-easter-etc -2 "Good Friday")
          (holiday-easter-etc +1 "Easter Monday")
          (holiday-fixed 4 25    "Anzac Day")
          ;; Anzac day holiday
          (holiday-float 6 1 1   "Western Australia Day")
          (holiday-float 9 1 4   "Queens Birthday")
          (holiday-float 10 1 4  "Labour Day")
          (holiday-fixed 12 25   "Christmas Day")
          (holiday-fixed 12 26   "Boxing Day")
          ;; (holiday-sexp '(next-week-day-holiday 26 12)
          ;;               "Boxing Day Holiday")
          ))

  ;;(setq org-agenda-include-diary t)

  (setq holiday-general-holidays nil)
  (setq holiday-christian-holidays nil)
  (setq holiday-hebrew-holidays nil)
  (setq holiday-islamic-holidays nil)
  (setq holiday-bahai-holidays nil)
  (setq holiday-oriental-holidays nil)
#+end_src
** Features
*** Auto-Completion
Auto-completion at point. Display a small pop-in containing the candidates.

#+begin_quote
 Company is a text completion framework for Emacs. The name stands for "complete
 anything". It uses pluggable back-ends and front-ends to retrieve and display
 completion candidates.

 [[http://company-mode.github.io/][Dmitry Gutov]]
#+end_quote

 #+begin_src emacs-lisp
 (use-package company
   :blackout
   :bind
   (:map company-active-map
         ("RET" . nil)
         ([return] . nil)
         ("TAB" . company-complete-selection)
         ([tab] . company-complete-selection)
         ("<right>" . company-complete-common))
   :hook
   (after-init . global-company-mode)
   :custom
   (company-dabbrev-downcase nil)
   (company-idle-delay .2)
   (company-minimum-prefix-length 1)
   (company-require-match nil)
   (company-tooltip-align-annotations t))
 #+end_src
*** Spelling
I'm not very good at spelling.
#+begin_src emacs-lisp
  ;; avoid spell-checking doublon (double word) in certain major modes
  (use-package flyspell
    :straight nil
    :blackout " â“’"
    :hook
    (text-mode . flyspell-mode)
    (prog-mode . flyspell-prog-mode)
    :config
    (progn
      (setq ispell-program-name "aspell"
            ispell-dictionary "australian"
            ispell-extra-args '("--sug-mode=ultra")
            ispell-silently-savep t)
      (add-hook 'ispell-initialize-spellchecker-hook
                (lambda ()
                  (setq ispell-base-dicts-override-alist
                        '((nil ; default
                           "[A-Za-z]" "[^A-Za-z]" "[']" t
                           ("-d" "en_GB" "--encoding=utf-8") nil utf-8)
                          ("australian"
                           "[A-Za-z]" "[^A-Za-z]" "[']" t
                           ("-d" "en_AU" "--encoding=utf-8") nil utf-8)
                          ("american" ; Yankee English
                           "[A-Za-z]" "[^A-Za-z]" "[']" t
                           ("-d" "en_US" "--encoding=utf-8") nil utf-8)
                          ("british" ; British English
                           "[A-Za-z]" "[^A-Za-z]" "[']" t
                           ("-d" "en_GB" "--encoding=utf-8") nil utf-8)))))))
#+end_src
*** Flycheck
#+begin_src emacs-lisp
  (use-package flycheck
    :commands flycheck-mode
    :blackout " â’»"
    :defer t
    :config
    (progn

      ;; color mode line faces
      (defun monkey/defface-flycheck-mode-line-color (state)
        "Define a face for the given Flycheck STATE."
        (let* ((fname (intern (format "monkey-mode-line-flycheck-%s-face"
                                      (symbol-name state))))
               (foreground (face-foreground
                            (intern (format "flycheck-fringe-%s" state)))))
          (eval `(defface ,fname '((t ()))
                   ,(format "Color for Flycheck %s feedback in mode line."
                            (symbol-name state))
                   :group 'monkey))
          (set-face-attribute fname nil
                              :foreground foreground
                              :box (face-attribute 'mode-line :box))))

      (defun monkey/set-flycheck-mode-line-faces ()
        "Define or set the flycheck info mode-line faces."
        (mapcar 'monkey/defface-flycheck-mode-line-color
                '(error warning info)))
      (monkey/set-flycheck-mode-line-faces)

      (defmacro monkey/custom-flycheck-lighter (error)
        "Return a formatted string for the given ERROR (error, warning, info)."
        `(let* ((error-counts (flycheck-count-errors
                               flycheck-current-errors))
                (errorp (flycheck-has-current-errors-p ',error))
                (err (or (cdr (assq ',error error-counts)) "?"))
                (running (eq 'running flycheck-last-status-change)))
           (if (or errorp running) (format "%s " err))))

      ;; Custom fringe indicator
      (when (fboundp 'define-fringe-bitmap)
        (define-fringe-bitmap 'my-flycheck-fringe-indicator
          (vector #b00000000
                  #b00000000
                  #b00000000
                  #b00000000
                  #b00000000
                  #b00000000
                  #b00000000
                  #b00011100
                  #b00111110
                  #b00111110
                  #b00111110
                  #b00011100
                  #b00000000
                  #b00000000
                  #b00000000
                  #b00000000
                  #b01111111)))

      (flycheck-define-error-level 'error
        :overlay-category 'flycheck-error-overlay
        :fringe-bitmap 'my-flycheck-fringe-indicator
        :fringe-face 'flycheck-fringe-error)

      (flycheck-define-error-level 'warning
        :overlay-category 'flycheck-warning-overlay
        :fringe-bitmap 'my-flycheck-fringe-indicator
        :fringe-face 'flycheck-fringe-warning)

      (flycheck-define-error-level 'info
        :overlay-category 'flycheck-info-overlay
        :fringe-bitmap 'my-flycheck-fringe-indicator
        :fringe-face 'flycheck-fringe-info)

      (add-hook 'after-init-hook #'global-flycheck-mode)))

  (flycheck-define-checker proselint
    "A linter for prose."
    :command ("proselint" source-inplace)
    :error-patterns
    ((warning line-start (file-name) ":" line ":" column ": "
              (id (one-or-more (not (any " "))))
              (message (one-or-more not-newline)
                       (zero-or-more "\n" (any " ") (one-or-more not-newline)))
              line-end))
    :modes (text-mode markdown-mode gfm-mode org-mode))

  (use-package flycheck-pos-tip
    :init (eval-after-load 'flycheck
            '(setq flycheck-display-errors-function #'flycheck-pos-tip-error-messages)))
#+end_src
*** Window and Buffers
Allow undo's and redo's with window configurations.

#+begin_quote
Winner mode is a global minor mode that records the changes in the window
configuration (i.e. how the frames are partitioned into windows) so that the
changes can be "undone" using the command =winner-undo=.  By default this one is
bound to the key sequence ctrl-c left.  If you change your mind (while undoing),
you can press ctrl-c right (calling =winner-redo=).

[[https://github.com/emacs-mirror/emacs/blob/master/lisp/winner.el][Ivar Rummelhoff]]
#+end_quote

#+begin_src emacs-lisp
(use-package winner
  :ensure nil
  :hook (after-init . winner-mode))
#+end_src

** Ivy

#+begin_quote
Ivy is a generic completion mechanism for Emacs. While it operates similarly to
other completion schemes such as =icomplete-mode=, Ivy aims to be more
efficient, smaller, simpler, and smoother to use yet highly customizable.

[[https://github.com/abo-abo/swiper#ivy][Oleh Krehel]]
#+end_quote

#+begin_src emacs-lisp
(use-package ivy
  :blackout
  :hook
  (after-init . ivy-mode)
  :chords (("FF" . find-file))
  :bind
  (:map ivy-minibuffer-map
        ("C-<down>" . ivy-next-line-and-call)
        ("C-<up>" . ivy-previous-line-and-call))
  :custom
  (ivy-count-format "")
  (ivy-display-style nil)
  (ivy-initial-inputs-alist nil)
  (ivy-re-builders-alist '((t . ivy--regex-plus)))
  (ivy-format-functions-alist '((t . ivy-format-function-line))))
#+end_src

Use posframe to display candidates.

#+begin_src emacs-lisp
(use-package ivy-posframe
  :blackout
  :hook
  (after-init . ivy-posframe-mode)
  :custom
  (ivy-posframe-display-functions-alist '((t . ivy-posframe-display-at-frame-center)))
  (ivy-posframe-height-alist '((t . 24)))
  (ivy-posframe-parameters '((alpha . 90)
                             (border-width . 0)
                             (internal-border-width . 16))))
#+end_src

Augment Ivy's interface with details for candidates.

#+begin_src emacs-lisp
(use-package ivy-rich
  :hook (after-init . ivy-rich-mode))
#+end_src
*** Ivy / Counsel

#+begin_src emacs-lisp
(use-package counsel
  :blackout
  :after ivy
  :config
  (counsel-mode 1)
  (setq-default ivy-initial-inputs-alist nil))
(use-package counsel-projectile
  :after ivy
  :config
  (counsel-projectile-mode 1)
  (setq-default ivy-initial-inputs-alist nil))
#+end_src

*** Ivy / Swiper

#+begin_src emacs-lisp
(use-package swiper
  :preface
  (defun me/swiper ()
    "`swiper' with string returned by `ivy-thing-at-point' as initial input."
    (interactive)
    (swiper (ivy-thing-at-point)))
  :bind ("C-s" . me/swiper)
  :custom (swiper-goto-start-of-match t))
#+end_src
** Hydra
Hydra allows to have a group of similar actions bound together for quick access, given an initial keybind. It will also show the available options in a the echo area.
#+begin_src emacs-lisp
  (use-package hydra
    :preface
    (defvar-local luminousmonkey/ongoing-hydra nil)
    (defun luminousmonkey/ongoing-hydra ()
      (interactive)
      (if luminousmonkey/ongoing-hydra-body
          (funcall luminousmonkey/ongoing-hydra-body)
        (user-error "luminousmonkey/ongoing-hydra: luminousmonkey/ongoing-hydra is not set"))))
#+end_src
*** Hydra / Dates
Group date-related commands.

#+begin_src emacs-lisp
  (defhydra hydra-dates (:color blue)
    "
  ^
  ^Dates^             ^Insert^            ^Insert with Time^
  ^â”€â”€â”€â”€â”€^â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€^â”€â”€â”€â”€â”€â”€^â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€^â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€^â”€â”€
  _q_ quit            _d_ short           _D_ short
  ^^                  _i_ iso             _I_ iso
  ^^                  _l_ long            _L_ long
  ^^                  ^^                  ^^
  "
    ("q" nil)
    ("d" me/date-short)
    ("D" me/date-short-with-time)
    ("i" me/date-iso)
    ("I" me/date-iso-with-time)
    ("l" me/date-long)
    ("L" me/date-long-with-time))
#+end_src
** Projectile
Projectile brings project-level facilities to Emacs such as grep, find and
replace.

#+begin_quote
Projectile is a project interaction library for Emacs. Its goal is to provide a
nice set of features operating on a project level without introducing external
dependencies (when feasible). For instance - finding project files has a
portable implementation written in pure Emacs Lisp without the use of GNU find
(but for performance sake an indexing mechanism backed by external commands
exists as well).

[[https://github.com/bbatsov/projectile][Bozhidar Batsov]]
#+end_quote

#+begin_src emacs-lisp
  (use-package projectile
    :hook
    (after-init . projectile-global-mode)
    :init
    (setq-default
     projectile-cache-file (expand-file-name ".projectile-cache" user-emacs-directory)
     projectile-known-projects-file (expand-file-name ".projectile-bookmarks" user-emacs-directory))
    :custom
    (projectile-enable-caching t))
#+end_src
** Quality of Life

Auto-indent code as you write.

#+begin_quote
=electric-indent-mode= is enough to keep your code nicely aligned when all you
do is type. However, once you start shifting blocks around, transposing lines,
or slurping and barfing sexps, indentation is bound to go wrong.

=aggressive-indent-mode= is a minor mode that keeps your code *always* indented.
It reindents after every change, making it more reliable than
electric-indent-mode.

[[https://github.com/Malabarba/aggressive-indent-mode][Artur Malabarba]]
#+end_quote

#+begin_src emacs-lisp
  (use-package aggressive-indent
    :blackout (aggressive-indent-mode . " â‡‰")
    :preface
    (defun me/aggressive-indent-mode-off ()
      (aggressive-indent-mode 0))
    :hook
    ((css-mode . aggressive-indent-mode)
     (emacs-lisp-mode . aggressive-indent-mode)
     (js-mode . aggressive-indent-mode)
     (lisp-mode . aggressive-indent-mode)
     (sgml-mode . aggressive-indent-mode)
     (clojure-mode . aggressive-indent-mode))
    :custom
    (aggressive-indent-comments-too t)
    :config
    (add-to-list 'aggressive-indent-protected-commands 'comment-dwim))
#+end_src
** Note-taking
#+begin_src emacs-lisp
  (use-package org-roam
    :ensure nil
    :commands (org-roam-build-cache)
    :straight (:host github :repo "jethrokuan/org-roam")
    :hook
    (after-init . org-roam-mode)
    :bind (:map org-roam-mode-map
                (("C-c n l" . org-roam)
                 ("C-c n f" . org-roam-find-file)
                 ("C-c n g" . org-roam-show-graph)
                 ("C-c n b" . org-roam-switch-to-buffer))
                :map org-mode-map
                (("C-c n i" . org-roam-insert)))
    :custom
    (org-roam-directory "~/Dropbox/Braindump/"))
#+end_src

#+begin_src emacs-lisp
  (use-package org-ref
    :after org
    :init
    (setq org-ref-completion-library 'org-ref-ivy-cite)
    (setq reftex-default-bibliography '("~/Dropbox/Research/references.bib"))
    (setq org-ref-bibliography-notes "~/Dropbox/Research/notes/notes.org"
          org-ref-default-bibliography '("~/Dropbox/Research/references.bib")
          org-ref-pdf-directory "~/Dropbox/papers/")
    (require 'doi-utils)
    (require 'org-ref-isbn))
#+end_src
